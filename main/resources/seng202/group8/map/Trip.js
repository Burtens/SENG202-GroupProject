let nthFlightToBeGenerated = 0;
let autoGeneratedDate = Date.now();

class Flight {
    constructor(comment, sourceCode, destinationCode, airlineCode, takeoffDate) {
        this.comment = comment;
        this.sourceCode = sourceCode;
        this.destinationCode = destinationCode;
        this.airlineCode = airlineCode
        this.takeoffDate = takeoffDate;
        this.route = undefined;
        this.trip = undefined; // Trip the flight is part of
        this.popup = undefined;
        this.count = 0; // nth flight in the trip
    }

    /**
     * Checks that the route is defined i.e. that the references to other data objects exists
     */
    isValid() {
        return this.route != undefined && this.trip != undefined;
    }


    generatePopup() {
        if (this.popup == undefined) {
            this.popup = new Popup(this);
        }
        return this.popup;
    }

    /**
     * Attempts to find the route the flight uses from an array of routes
     * @param {Route[]} routes array of routes to search from
     */
    getRoute(routes) {
        // Assuming there is only one trip so searching through the list is probably not too bad performance-wise
        routes.forEach(route => {
            if (route.sourceCode == this.sourceCode && route.destinationCode == this.destinationCode && route.airlineCode == this.airlineCode) {
                this.route = route;
            }
        });
    }


    /**
     * Generates the HTML for the popup as a string
     * @param {integer} count number of the flight in the list of the trip
     */
    generatePopupHTMLAsString() {
        if (this.isValid() && this.route.isValid()) {
            let pad = num => {
                return (num < 10? "0": "") + num
            }

            let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

            let timeFormat = date => {
                return `${pad(date.getUTCHours())}:${pad(date.getUTCMinutes())}`;
            }

            let dateFormatTakeoff = date => {
                return `${timeFormat(date)}, ${date.getUTCDate()} ${months[date.getUTCMonth()]} ${date.getUTCFullYear()}`;
            }

            let dateFormatLanding = (start, end) => {
                let datesEqual = start.getUTCDay() == end.getUTCDay();
                let monthsEqual = start.getUTCMonth() == end.getUTCMonth();
                let yearsEqual = start.getUTCFullYear() == end.getUTCFullYear();

                if (!yearsEqual) {
                    return dateFormatTakeoff(end);
                } else {
                    if (datesEqual && monthsEqual) {
                        return timeFormat(end);
                    } else {
                        return `${timeFormat(end)}, ${end.getUTCDate()} ${months[end.getUTCMonth()]}`;
                    }
                }
            }

            let formatDuration = duration => {
                let hours = Math.floor(duration / 60)
                let minutes = Math.floor(duration % 60)
                let minutesText = `${minutes} minute${minutes == 1? "": "s"}`
                if (duration < 60) {
                    return minutesText;
                } else {
                    let hoursText = `${hours} hour${hours == 1? "": "s"}`
                    if (minutes != 0) {
                        return hoursText + " " + minutesText;
                    }
                    return hoursText;
                }
            }

            let landingDate = new Date(this.takeoffDate.valueOf() + this.route.duration * 60 * 1000);

            return `
                <div class="popup-title">${this.count}: ${this.sourceCode} &rarr; ${this.destinationCode}</div>`
                // <div class="popup-airports">${this.route.sourceAirport.name} to ${this.route.destinationAirport.name}</div>
                // <div class="popup-time">Depart: ${dateFormatTakeoff(this.takeoffDate)}</div>
                // <div class="popup-time">Land: ${dateFormatLanding(this.takeoffDate, landingDate)} (${formatDuration(this.route.duration)})</div>`
        }
    }

    
    static generateRandomFlight(routes, airportsDictionary) {
        let comment = `${nthFlightToBeGenerated++}th flight to be generated`;
        let route = routes[randInt(0, routes.length - 1)];

        route.getAirports(airportsDictionary);
        if (!route.isValid()) {
            // Ensure a valid route is returned
            return this.generateRandomFlight(routes, airportsDictionary);
        }

        autoGeneratedDate += randInt(60,  60 * 40) * 60 * 1000; // Between 1 and 40 hours long
        let time = new Date(autoGeneratedDate);

        return new Flight(comment, route.sourceCode, route.destinationCode, route.airlineCode, time);
    }

}

class Trip {
    constructor(name, comment, flights) {
        this.name = name;
        this.comment = comment;
        this.flights = flights;

        for(let i = 0; i < this.flights.length; i++) {
            this.flights[i].count = i + 1;
            this.flights[i].trip = this;
        }
    }

    static generateRandomTrip(routes, airportsDictionary) {
        let name = "Trip name";
        let comment = "Some long comment";

        let flights = [];
        let numFlights = randInt(2, 10);
        for(let i = 0; i < numFlights; i++) {
            flights.push(Flight.generateRandomFlight(routes, airportsDictionary));
        }

        return new Trip(name, comment, flights);

    }
}